{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Study for jitter effect in Energy resolution \n",
    "\n",
    "for tessim-simulated files under different:\n",
    "\n",
    "* sampling rates\n",
    "* BBFB (yes/no)\n",
    "\n",
    "**stochastic + nobbfb = NO JITTER**\n",
    "\n",
    "**stochastic + bbfb = JITTER**\n",
    "\n",
    "**non-stochastic = JITTER**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ----IMPORT MODULES --------------\n",
    "from __future__ import print_function\n",
    "from __future__ import division\n",
    "from multiprocessing import Pool, cpu_count\n",
    "from itertools import repeat\n",
    "from subprocess import check_call, check_output,STDOUT\n",
    "from cycler import cycler\n",
    "from astropy.io import fits\n",
    "import math\n",
    "import sys, os\n",
    "import shutil, tempfile, shlex\n",
    "import re\n",
    "import warnings\n",
    "import numpy as np\n",
    "import auxpy\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "from matplotlib import cm\n",
    "from matplotlib.ticker import LinearLocator, FormatStrFormatter\n",
    "from ipywidgets import interact, interactive, fixed, interact_manual\n",
    "import ipywidgets as widgets\n",
    "\n",
    "cwd = os.getcwd()\n",
    "tmpDir = tempfile.mkdtemp()\n",
    "os.environ[\"PFILES\"] = tmpDir + \":\" + os.environ[\"PFILES\"]\n",
    "os.environ[\"HEADASNOQUERY\"] = \"\"\n",
    "os.environ[\"HEADASPROMPT\"] = \"/dev/null/\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Define auxiliary functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def recentre_offset(arrPhaseInit, Ymag, arrmethod, bbfb):\n",
    "        \"\"\"\n",
    "        For a plot Ymag vs arrPhase, this function recentre the offset\n",
    "        to get a smooth function  (~ parabola) for later fit\n",
    "            :param arrPhase: 1D array with calculated offset (X axis)\n",
    "            :param Ymag: 1D array with relevant magnitude for each offset\n",
    "            :param arrmethod: integer in [0-4] to select which offset has been calculated in arrivalPhase func\n",
    "            :param bbfb: \"\" if no BBFB and \"bbfb\" if BBFB is used\n",
    "        \"\"\"    \n",
    "        # If arrivalPhase1 or arrivalPhse2: (should be identical, apart from rounding errors...)\n",
    "        #             differences are calculated from non-jitter(simulated) times => if >1, subtract 1\n",
    "        #\n",
    "        # If arrivalPhase3: \n",
    "        #             differences are calculated from closest sample\n",
    "        #\n",
    "        # If arrivalPhase4: \n",
    "        #             differences are calculated from previous sample\n",
    "        #\n",
    "        #\n",
    "        #   arrPhase                non-stoch                               stoch+bbfb\n",
    "        #   ========         ============================          =================================\n",
    "        #     1/2               if >1, subtract 1                        (if >1, subtract 1) &\n",
    "        #                                                              offsets largest than minimum\n",
    "        #                                                             energy error must be moved to \n",
    "        #                                                              the left branch =>dome shape (~ -0.5-0.5)\n",
    "        #\n",
    "        #     3             Inconsistent low-high energies               ok - dome shape  (~ -0.5-0.5)\n",
    "        #                           \n",
    "        #                                         \n",
    "        #\n",
    "        #     4             offsets largest than maximum             offsets largest than minimum\n",
    "        #                   energy error must be moved to            energy error must be moved to \n",
    "        #                         the left branch                            the left branch (~ -0.5-0.5)\n",
    "        #\n",
    "        #\n",
    "\n",
    "        #\n",
    "        # For arrivalPhase3/4, offsets largest than maximum energy error must be moved to the left branch\n",
    "\n",
    "        imax = np.argmax(Ymag)\n",
    "        imin = np.argmin(Ymag)\n",
    "        \n",
    "        arrPhase = np.array(arrPhaseInit)\n",
    "        Ymag = np.asarray(Ymag)\n",
    "        \n",
    "        # Correction only applicable if arrmethod== 1 or 2 (only possible larger than 1 offsets):\n",
    "        for j in range(0,arrPhase.size):\n",
    "            if arrPhase[j] > 1:\n",
    "                arrPhase[j] -= np.floor(arrPhase[j])\n",
    "\n",
    "        if bbfb == \"\" and arrmethod == 4:\n",
    "            # print(\"Modifying offsets at \", arrPhase[imax])\n",
    "            for j in range(0,arrPhase.size):\n",
    "                if arrPhase[j] > arrPhase[imax]:\n",
    "                    arrPhase[j] -= 1\n",
    "        elif bbfb == \"\" and arrmethod == 3:\n",
    "            print(\"Error: arrival method=3 gives inconsistent curves for different energies\")\n",
    "            raise\n",
    "        elif bbfb == \"bbfb\" and arrmethod in (1,2,4):\n",
    "            for j in range(0,arrPhase.size):\n",
    "                if arrPhase[j] > arrPhase[imin]:\n",
    "                    arrPhase[j] -= 1\n",
    "        return arrPhase"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def tsdf(commToRun,tesF):\n",
    "    \"\"\"\n",
    "    Run simulation command for individual file and depurate tessim file\n",
    "    :param commToRun : command to run tessim simulation\n",
    "    :param tesF: simulation file (to remove last/first row)\n",
    "    \"\"\"\n",
    "    try:\n",
    "        args = shlex.split(commToRun)\n",
    "        check_call(args, stderr=STDOUT)\n",
    "    except RuntimeError:\n",
    "        print(\"Error running tool for tessim list generation\")\n",
    "        raise\n",
    "        \n",
    "    # update HISTORY\n",
    "    auxpy.updateHISTORY(tesF, commToRun)\n",
    "    # rm first (and LAST) record and update NETTOT\n",
    "    fsim = fits.open(tesF)\n",
    "    nrows = fsim[1].header[\"NAXIS2\"]\n",
    "    assert nrows > 1, \"Tessim failed: just one huge row present!\"\n",
    "    fsim.close()\n",
    "    \n",
    "    try:\n",
    "        print(\"Removing first & last row, just in case, and updating NETTOT\")\n",
    "        auxpy.rmLastAndFirst(tesF, 1)\n",
    "    except RuntimeError:\n",
    "        print(\"Error running FTOOLS to remove initial & last rows in \", tesF)\n",
    "        raise\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fit_2D_gain_scale(ph_values,phase_values,energy_list,deg=6,show=False):\n",
    "    '''Fits a 2D gain scale giving the energy as a function of ph and phase\n",
    "    \n",
    "    Arguments:\n",
    "        - ph_values: 2D array of the measured PH values\n",
    "        - phase_values: 2D array of the measured phase values\n",
    "        - energy_list: 1D array of the simulated energies\n",
    "        - deg: degree of the polynom to fit (in both X and Y)\n",
    "        - show: option to plot the results\n",
    "    '''\n",
    "    ph_values = np.array(ph_values)\n",
    "    phase_values = np.array(phase_values)\n",
    "    energies = np.array([energy_list for _ in range(len(ph_values[0]))]).transpose()\n",
    "    poly_coeffs = polyfit2d(ph_values, phase_values, energies, [deg,deg])\n",
    "    return poly_coeffs\n",
    "\n",
    "def polyfit2d(x, y, f, deg):\n",
    "    x = np.asarray(x)\n",
    "    y = np.asarray(y)\n",
    "    f = np.asarray(f)\n",
    "    deg = np.asarray(deg)\n",
    "    vander = np.polynomial.polynomial.polyvander2d(x, y, deg)\n",
    "    #print(vander.size)\n",
    "    #print(vander)\n",
    "    vander = vander.reshape((-1,vander.shape[-1]))\n",
    "    f = f.reshape((vander.shape[0],))\n",
    "    c = np.linalg.lstsq(vander, f)[0]\n",
    "    return c.reshape(deg+1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Define variables "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def initVars(noi,sto,bb,smp):\n",
    "    \"\"\"\n",
    "    Initialize global variables\n",
    "    \"\"\"\n",
    "\n",
    "    global jitter, noise, stoch, bbfb, smprt, npulses, npulsesLib, npulsesGain\n",
    "    global singleSeparation,preBufferSize,triggerSizeTC,triggerSizeTS,triggerTS3val\n",
    "    global eurecaDir, sixteDir, pairsDir, impDir, ereDir, tesDir\n",
    "    global pixtype, coeffsfile, eners_keV, calibEnergies, libEnergies, eners_keV, test_keV\n",
    "    global smprtStr, jitterStr, noiseStr,stochStr,bbfbStr\n",
    "    global samprate,pulseLength,nSamples,nSgms,samplesUp,samplesDown,xmlfile,expos\n",
    "    global tpulses,texpos,offset,simnoise,stochastic,dobbfb, arrMeth\n",
    "    global cols,impFs,imp0Fs, evtFs, calibFs, tesFs,impForNoise,forNoiseFile,noiseFile,libfile\n",
    "    global test_impFs,test_tesFs,test_evtFs,test_calibFs,tnoiseStr,tnpulsesLib,tlibfile\n",
    " \n",
    "    \n",
    "    #      Simulation options to calculate jitter correction\n",
    "    # ========================================================\n",
    "    jitter = \"jitter\" # \"\" or \"jitter\"\n",
    "    noise = noi # \"\" or \"nonoise\"\n",
    "    if noise == 'noise':\n",
    "        noise = ''\n",
    "    stoch = sto # \"stoch\" for stochastic simulator or \"nostoch\" for new tessim with no stochastic\n",
    "    if stoch == 'nostoch':\n",
    "        stoch = ''\n",
    "    bbfb = bb # \"\" for not_bbfb or \"bbfb\" for dobbfb in tessim \n",
    "    if bbfb == 'nobbfb':\n",
    "        bbfb = ''\n",
    "    smprt = smp # \"\" or \"samprate2\"\n",
    "    if smprt == 'samprate':\n",
    "        smprt = ''\n",
    "    npulsesLib  = 20000 # number of pulses for libraries\n",
    "    npulsesGain = 20000 # number of pulses for gainScale\n",
    "    singleSeparation = 40000\n",
    "    preBufferSize = 1000\n",
    "    triggerSizeTC = 1000 + 2*singleSeparation + 1000\n",
    "\n",
    "    eurecaDir = \"/dataj6/ceballos/INSTRUMEN/EURECA\"\n",
    "    sixteDir = eurecaDir + \"/testHarness/simulations/SIXTE\"\n",
    "    pairsDir = eurecaDir + \"/ERESOL/PAIRS\"\n",
    "    impDir = pairsDir + \"/PIXIMPACT\"\n",
    "    ereDir = pairsDir + \"/eresolLPA2shunt\"\n",
    "    tesDir = pairsDir + \"/tessimLPA2shunt\"\n",
    "\n",
    "    pixtype = \"'file:/dataj6/ceballos/INSTRUMEN/EURECA/testHarness/simulations/SIXTE/newpix_full.fits[LPA2shunt]'\"\n",
    "    coeffsfile = ereDir + \"/coeffs_polyfit.dat\"\n",
    "    eners_keV = (0.2, 0.5, 1, 2, 3, 4, 5, 6, 7, 8)\n",
    "    calibEnergies = [0.2, 0.5, 1, 2, 3, 4, 5, 6, 7, 8]\n",
    "    libEnergies = (6,)\n",
    "    eners_keV = (1, 2, 3, 4, 5, 6, 7, 8)\n",
    "    #eners_keV = (3, 4, 5, 6, 7, 8)\n",
    "    test_keV = (1, 7)\n",
    "\n",
    "    \n",
    "    # samprate\n",
    "    smprtStr = \"\"\n",
    "    if smprt == \"samprate2\":\n",
    "        smprtStr = \"_samprate2\"\n",
    "        samprate = 78125. # Hz\n",
    "        pulseLength = 4096\n",
    "        nSamples = 4096\n",
    "        largeFilter = 4096\n",
    "        nSgms = 6\n",
    "        samplesUp = 2\n",
    "        samplesDown = 3\n",
    "    else:\n",
    "        samprate = 156250. # Hz\n",
    "        pulseLength = 8192\n",
    "        nSamples = 8192\n",
    "        largeFilter = 8192\n",
    "        nSgms = 5\n",
    "        samplesUp = 3\n",
    "        samplesDown = 3\n",
    "        \n",
    "    if bbfb == \"\":\n",
    "        npulses = 1000 # number of pulses for analysis\n",
    "        tpulses = 2000 # number of pulses for test\n",
    "    else:\n",
    "        tpulses = 1000\n",
    "        npulses = 100 # number of pulses for analysis    \n",
    "    xmlfile = eurecaDir + \"/ERESOL/xifu_detector_hex_baselineNEWgrades\" + smprtStr + \".xml\"    \n",
    "    expos = '{0:0.0f}'.format(npulses/2. * triggerSizeTC/float(samprate))\n",
    "    triggerSizeTS = preBufferSize + pulseLength + 1000\n",
    "    triggerTS3val = triggerSizeTS - preBufferSize\n",
    "    texpos = '{0:0.0f}'.format(tpulses/2. * triggerSizeTC/float(samprate))\n",
    "\n",
    "    # jitter\n",
    "    jitterStr = \"\"\n",
    "    offset = 0\n",
    "    if jitter == \"jitter\":\n",
    "        jitterStr = \"_jitter\"\n",
    "        offset = -1\n",
    "    #noise\n",
    "    noiseStr = \"\"\n",
    "    simnoise = \"y\"\n",
    "    if noise == \"nonoise\":\n",
    "        noiseStr = \"_nonoise\"\n",
    "        simnoise = \"n\"\n",
    "    #stoch \n",
    "    stochStr = \"\"\n",
    "    stochastic = \" stochastic_integrator=n\"\n",
    "    if jitter == \"jitter\":\n",
    "        stochastic = \"\"\n",
    "    if stoch == \"stoch\":\n",
    "        stochStr = \"_stoch\"\n",
    "        stochastic = \" stochastic_integrator=y\"\n",
    "    #bbfb\n",
    "    bbfbStr = \"\"\n",
    "    dobbfb = \" dobbfb=n\"\n",
    "    if jitter == \"jitter\":\n",
    "        dobbfb = \"\"\n",
    "    if bbfb == \"bbfb\":\n",
    "        bbfbStr = \"_bbfb\"\n",
    "        dobbfb = \" dobbfb=y carrier_frequency = 2e6 bbfb_delay = 40 decimation_filter = y\"\n",
    "\n",
    "    if stoch == \"\":\n",
    "        arrMeth = 4\n",
    "    else:\n",
    "        arrMeth = 3\n",
    "            \n",
    "    # check consistency among simulation options\n",
    "    if jitter == \"jitter\" and stoch == \"stoch\" and bbfb == \"\":\n",
    "        raise ValueError(\"Jitter is not possible with stoch & noBBFB\")\n",
    "    elif stoch == \"\" and bbfb == \"bbfb\":\n",
    "        raise ValueError(\"BBFB is not possible without stoch\")\n",
    "    elif stoch == \"stoch\" and bbfb == \"\":\n",
    "        warnings.warn(\"Stochastic simulation but no jitter will be generated!\")\n",
    "\n",
    "    cols = [(0,0,0),(87,87,87),(173,35,35),(42,75,215),(29,105,20),(129,74,25),(129,38,192),(160,160,160), (129,197,122),(157,175,255),(41,208,208),(255,146,51),(255,238,51),(233,222,187),(255,205,243),(255,255,255)]\n",
    "    cols = [(165,0,38),(215,48,39),(244,109,67),(253,174,97),(254,224,144),(224,243,248),(171,217,233),(116,173,209),\n",
    "            (69,117,180),(49,54,149)]\n",
    "    reversed_cols = cols[::-1]\n",
    "    for i in range(0,len(cols)):\n",
    "            cols[i] = tuple(round((x/255.),2) for x in reversed_cols[i])\n",
    "            # print(\"Color=\", cols[i])\n",
    "\n",
    "    # a) Filenames for surface fitting and dependency curves\n",
    "    # ========================================================\n",
    "    impFs = list()\n",
    "    imp0Fs = list()\n",
    "    evtFs = list()\n",
    "    calibFs = list()\n",
    "    tesFs = list()\n",
    "    impForNoise = \"forNoise\" + str(pulseLength) + \"samples_tessimLPA2shunt_100s_pairscps_ADC\" + smprtStr + \".piximpact\"\n",
    "    forNoiseFile = (\"forNoise\" + str(pulseLength) + \"samples_tessimLPA2shunt_100s_pairscps_ADC\" +\n",
    "                    smprtStr + stochStr + bbfbStr + \".fits\")\n",
    "    noiseFile = \"noise\" + str(pulseLength) + \"samples_tessimLPA2shunt_B0_ADC\" + smprtStr + stochStr + bbfbStr + \".fits\"\n",
    "    #libfile = (sixteDir + \"/LIBRARIES/tessimLPA2shunt/GLOBAL/ADC/libraryMultiE_GLOBAL_PL\" + str(pulseLength) + \"_\" +\n",
    "    #           str(npulsesLib) + \"p\" + jitterStr + noiseStr + stochStr + bbfbStr + \".fits\")\n",
    "    libfile = (sixteDir + \"/LIBRARIES/tessimLPA2shunt/GLOBAL/ADC/library6keV_PL\" + str(pulseLength) + \"_\" +\n",
    "               str(npulsesLib) + \"p\" + smprtStr + jitterStr + noiseStr + stochStr + bbfbStr + \".fits\")\n",
    "\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        file = (impDir + \"/sep40000sam_\" + str(expos) + \"s_\" + str(eners_keV[i]) + \"keV\" +\n",
    "                smprtStr + jitterStr + \"_trSz82000.piximpact\")\n",
    "        impFs.append(file)\n",
    "\n",
    "        file = (impDir + \"/sep40000sam_\" + str(expos) + \"s_\" + str(eners_keV[i]) + \"keV\" +\n",
    "                smprtStr + \"_trSz82000.piximpact\")\n",
    "        imp0Fs.append(file)\n",
    "\n",
    "        file = (tesDir + \"/sep40000sam_\" + str(npulses) + \"p_\" + str(eners_keV[i]) + \"keV\" +\n",
    "                smprtStr + jitterStr + noiseStr + stochStr + bbfbStr + \".fits\")\n",
    "        tesFs.append(file)\n",
    "\n",
    "        file = (ereDir + \"/events_sep40000sam_\" + str(npulses) + \"p_SIRENA\" + str(pulseLength)+ \"_pL\" +\n",
    "                str(pulseLength) + \"_\" + str(eners_keV[i]) + \"keV_STC_F0F_fixedlib6OF_OPTFILT\" + \n",
    "                str(pulseLength) + smprtStr + jitterStr + noiseStr + stochStr + bbfbStr + \".fits\")\n",
    "        evtFs.append(file)\n",
    "\n",
    "        file = (ereDir + \"/events_sep40000sam_\" + str(npulses) + \"p_SIRENA\" + str(pulseLength)+ \"_pL\" +\n",
    "                str(pulseLength) + \"_\" + str(eners_keV[i]) + \"keV_STC_F0F_fixedlib6OF_OPTFILT\" + \n",
    "                str(pulseLength) + smprtStr + jitterStr + noiseStr + stochStr + bbfbStr + \".calib\")\n",
    "        calibFs.append(file)\n",
    "\n",
    "    # b) Filenames for test\n",
    "    # =====================\n",
    "    test_impFs = list()\n",
    "    test_tesFs = list()\n",
    "    test_evtFs = list()\n",
    "    test_calibFs = list()\n",
    "    tnoiseStr = \"\"\n",
    "    # Simulate & reconstruct noisy files\n",
    "    if bbfb == \"\":\n",
    "        tnpulsesLib = 20000\n",
    "    else:\n",
    "        tnpulsesLib = 50\n",
    "\n",
    "    tlibfile = (sixteDir + \"/LIBRARIES/tessimLPA2shunt/GLOBAL/ADC/library6keV_PL\" + str(pulseLength) + \"_\" +\n",
    "               str(tnpulsesLib) + \"p\" + smprtStr + jitterStr + tnoiseStr + stochStr + bbfbStr + \".fits\")\n",
    "\n",
    "    for i in range(len(test_keV)):\n",
    "        file = (impDir + \"/sep40000sam_\" + str(texpos) + \"s_\" + str(test_keV[i]) + \"keV\" +\n",
    "                smprtStr + jitterStr + \"_trSz82000.piximpact\")\n",
    "        test_impFs.append(file)\n",
    "        file = (tesDir + \"/sep40000sam_\" + str(tpulses) + \"p_\" + str(test_keV[i]) + \"keV\" +\n",
    "                smprtStr + jitterStr + tnoiseStr + stochStr + bbfbStr + \".fits\")\n",
    "        test_tesFs.append(file)\n",
    "        file = (ereDir + \"/events_sep40000sam_\" + str(tpulses) + \"p_SIRENA\" + str(pulseLength)+ \"_pL\" +\n",
    "                str(pulseLength) + \"_\" + str(test_keV[i]) + \"keV_STC_F0F_fixedlib6OF_OPTFILT\" + \n",
    "                str(pulseLength) + smprtStr + jitterStr + tnoiseStr + stochStr + bbfbStr + \".fits\")\n",
    "        test_evtFs.append(file)\n",
    "        file = (ereDir + \"/events_sep40000sam_\" + str(tpulses) + \"p_SIRENA\" + str(pulseLength)+ \"_pL\" +\n",
    "                str(pulseLength) + \"_\" + str(test_keV[i]) + \"keV_STC_F0F_fixedlib6OF_OPTFILT\" + \n",
    "                str(pulseLength) + smprtStr + jitterStr + tnoiseStr + stochStr + bbfbStr + \".calib\")\n",
    "        test_calibFs.append(file)\n",
    "\n",
    "# required for data creation and pre-processing        \n",
    "#initVars(noi='noise',sto='nostoch',bb='nobbfb',smp='samprate')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Pre-processing: noise file, library, gain scale coefficients\n",
    "\n",
    "## 1. Create Noise file\n",
    "\n",
    "In shell:\n",
    "\n",
    "```\n",
    "> python simulNoise.py --pixName=LPA2shunt --stoch=stoch --bbfb=bbfb --jitter=jitter\n",
    "            --pulseLength=8192 --space=ADC --simTime=100 --pixel=1\n",
    "```\n",
    "\n",
    "Since stochastic simulations need a large amount of time, noise files creation is done in 10 parallel processes. Tessim is run first so that only the \"forNoise*\" files are created. Then all of them are merged with \"fmerge\" and then the noise spectrum file is created."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#auxpy.simulNoise(pixName='LPA2shunt', samprate=smprt, jitter=jitter,\n",
    "#                 stoch=stoch, bbfb=bbfb, pulseLength=pulseLength,\n",
    "#                 space='ADC', acbias='yes', scaleFactor=0, samplesUp=2, nSgms=5,\n",
    "#                 nintervals=1000, simTimeN=100, pixel=1, preBufferSize=1000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Create Library file\n",
    "\n",
    "Create libfile = sixteDir + /LIBRARIES/tessimLPA2shunt/GLOBAL/ADC/libraryMultiE_GLOBAL_PL(pulseLength)_(npulsesLib)p_(jitterStr)(noiseStr)(stochStr).fits\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run = 0\n",
    "if run:\n",
    "    initVars(noi='nonoise',sto='nostoch',bb='nobbfb',smp='samprate')\n",
    "    #sys.exit()\n",
    "    print(\"Creating library of \",npulsesLib,\"pulses for:\")\n",
    "    print(\"jitter=\",jitter,\"noise=\",noise,\"bbfb=\",bbfb,\"samprate=\",smprtStr)\n",
    "    ## Create library: template files + multiE library\n",
    "    auxpy.simulLibsGlobal(pixName='LPA2shunt', space='ADC',\n",
    "                        samprate=smprt, jitter=jitter,\n",
    "                        noise=noise, stoch=stoch,\n",
    "                        bbfb=bbfb, pulseLength=pulseLength,\n",
    "                        largeFilter=pulseLength,\n",
    "                        libEnergies=libEnergies,\n",
    "                        nsamples=nSamples, acbias='yes',\n",
    "                        nSimPulses=npulsesLib, createLib=1, \n",
    "                        tstartPulse1All=[0,0,0,0,0,0,0,0,0,0],\n",
    "                        noiseMat='no', weightMat='no',\n",
    "                        pixel=1, preBufferSize=1000, separation=40000)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Calculate GAINSCALE"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.1 . Simulate single files (in gainScales dir)\n",
    "\n",
    "Run in shell (for each energy of calibration):\n",
    "```\n",
    "> python simulSingles.py --pixName=LPA2shunt --monoEkeV=0.2 --samprate=smprt --jitter=jitter\n",
    "--noise=noise --stoch=stoch\n",
    "```\n",
    "\n",
    "and then, move files to tessimLPA2shunt/gainScale dir.\n",
    "\n",
    "Or..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# simulate single files for GainScale\n",
    "run = 0\n",
    "#auxpy.simulSingles(pixName='LPA2shunt', monoEkeV=mono, acbias='yes',\n",
    "#                       samprate=smprt, jitter=jitter, noise=noise,\n",
    "#                       stoch=stoch, bbfb=bbfb, nSimPulses=npulsesGain, \n",
    "#                       singleSeparation=singleSeparation, pixel=1,\n",
    "#                       preBufferSize=1000, pulseLength=pulseLength)\n",
    "if run:\n",
    "    initVars(noi='nonoise',sto='nostoch',bb='nobbfb',smp='samprate')\n",
    "    print(\"Creating GAIN SCALE \",npulsesLib,\"pulses for:\")\n",
    "    print(\"jitter=\",jitter,\"noise=\",noise,\"bbfb=\",bbfb,\"samprate=\",smprtStr)\n",
    "    # optimize for multicore: run simulation in parallel\n",
    "    nproc = cpu_count()\n",
    "    #print(\"nproc=\",nproc)\n",
    "    with Pool(processes=nproc) as pool:\n",
    "        pool.starmap(auxpy.simulSingles, zip(repeat('LPA2shunt'), calibEnergies,\n",
    "                                             repeat('y'),repeat(smprt),repeat(jitter),\n",
    "                                             repeat(noise),repeat(stoch),repeat(bbfb),\n",
    "                                             repeat(npulsesGain), repeat(singleSeparation),\n",
    "                                             repeat(1), repeat(1000), repeat(pulseLength)))\n",
    "    pool.close()\n",
    "    pool.join()\n",
    "    \n",
    "    for mono in calibEnergies: \n",
    "        singleFile = (\"sep\" + str(singleSeparation) + \"sam_\" + str(npulsesGain) + \"p_\" + \n",
    "                      str(mono) + \"keV\" + smprtStr + jitterStr + noiseStr + stochStr + \".fits\")\n",
    "        shutil.move((tesDir + \"/\" + singleFile), (tesDir + \"/gainScale/\" + singleFile))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.2 . Reconstruct single files\n",
    "\n",
    "Run in shell:\n",
    "```\n",
    "> source /dataj6/ceballos/INSTRUMEN/EURECA/ERESOL/runCompareACDCpy.csh 1\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.3. Get GAINSCALE from R script: polyfit2Bias.R\n",
    "\n",
    "This will create the coefficients file (*/dataj6/ceballos/INSTRUMEN/EURECA/ERESOL/PAIRS/eresolLPA2shunt/coeffs_polyfit.dat*):\n",
    "\n",
    "```\n",
    "\"METHODS\" \"ALIAS\" \"a0\" \"a1\" \"a2\" \"a3\" \"a4\"\n",
    "\"OPTIMAL FILTERING (fixed OF 6keV filter samprate) STC, nonoise\" \"STC_fixedlib6OF_OPTFILT8192_jitter_nonoise\" 0.00245024600675378 1.2539667770017 -0.0492489724547103 0.00118023200208777 0\n",
    "\"OPTIMAL FILTERING (fixed OF 6keV filter samprate) STC, nonoise, stoch, bbfb\" \"STC_fixedlib6OF_OPTFILT8192_jitter_nonoise_stoch_bbfb\" 0.000154277251777552 1.25883695701217 -0.0523367084509556 0\n",
    ".00178137217747703 -3.62793675936531e-05\n",
    "```\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Create data files for surface fitting (NONOISE)\n",
    "\n",
    "PIXIMPACT -> TESSIM -> SIRENA(STC) -> CALIBRATED\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "initVars(noi='nonoise',sto='nostoch',bb='nobbfb',smp='samprate')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run = 0\n",
    "# 1) Create Piximpact file nonoise, stoch, bbfb\n",
    "# ==========================================================\n",
    "if run: \n",
    "    for i in range(0,len(eners_keV)):\n",
    "        comm0 = (\"tesconstpileup PixImpList=\" + imp0Fs[i] + \" XMLFile=\" + xmlfile + \" timezero=0 tstop=\" + str(expos) +\n",
    "                 \" energy=\" + str(eners_keV[i]) + \" offset=0 pulseDistance=\" + str(singleSeparation) +\n",
    "                 \" TriggerSize=\" + str(triggerSizeTC) + \" clobber=yes\")\n",
    "        try:\n",
    "            args = shlex.split(comm0)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for piximpact (no jitter) list generation\")\n",
    "            os.chdir(cwd)\n",
    "            shutil.rmtree(tmpDir)\n",
    "            raise\n",
    "        #print(\"Created \", imp0Fs[i])\n",
    "\n",
    "        comm = (\"tesconstpileup PixImpList=\" + impFs[i] + \" XMLFile=\" + xmlfile + \" timezero=0 tstop=\" + \n",
    "                str(expos) + \" energy=\" + str(eners_keV[i]) + \" offset=\" + str(offset) + \" pulseDistance=\" +\n",
    "                str(singleSeparation) + \" TriggerSize=\" + str(triggerSizeTC) + \" clobber=yes\")\n",
    "        try:\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for piximpact list generation\")\n",
    "            os.chdir(cwd)\n",
    "            shutil.rmtree(tmpDir)\n",
    "            raise\n",
    "        print(\"Created \", impFs[i])\n",
    "    print(\"########################\")        \n",
    "    print(\"PIXIMPACT/0 files created\")\n",
    "    print(\"########################\")        \n",
    "#sys.exit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "run = 0\n",
    "# 2) Create tessimfile nonoise, jitter, stoch, bbfb\n",
    "# ==========================================================\n",
    "# Create individual commands for each simulation\n",
    "comms = []\n",
    "if run:\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        streamFile = \"events_\" + str(eners_keV[i]) + \".stream\"\n",
    "        command = (\"tessim PixID=1 PixImpList=\" + impFs[i] + \" Streamfile=\" + tesFs[i] + \n",
    "                   \" tstart=0. tstop=\" + str(expos) +  \" clobber=yes\" +\n",
    "                   \" triggerSize=\" + str(triggerSizeTS) + \" preBuffer=1000 \" +\n",
    "                   \" triggertype='diff:3:20:\" + str(triggerTS3val) + \"'\" +\n",
    "                   \" sample_rate=\" + str(samprate) + \" PixType=\" + pixtype +\n",
    "                   \" doCrosstalk=n simnoise=n\" + stochastic + dobbfb)\n",
    "        comms.append(command)\n",
    "\n",
    "    # optimize for multicore: run simulation in parallel\n",
    "    nproc = cpu_count()\n",
    "    #print(\"nproc=\",nproc)\n",
    "    with Pool(processes=nproc) as pool:\n",
    "        pool.starmap(tsdf, zip(comms, tesFs))\n",
    "    pool.close()\n",
    "    pool.join()\n",
    "\n",
    "    print(\"########################\")        \n",
    "    print(\"TESSIM files created\")            \n",
    "    print(\"########################\")  \n",
    "#sys.exit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "run = 1\n",
    "# 3) Run SIRENA (AD,STC)\n",
    "# =======================\n",
    "if run:\n",
    "    print(\"Reconstructing\",npulses, \"single files with lib of \",npulsesLib,\"pulses for:\")\n",
    "    print(\"jitter=\",jitter,\"noise=\",noise,\"bbfb=\",bbfb,\"samprate=\",smprtStr)\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        comm = (\"tesreconstruction Recordfile=\" + tesFs[i] + \" TesEventFile=\" + evtFs[i] + \" Rcmethod=SIRENA\" + \n",
    "                \" PulseLength=\"+ str(pulseLength) + \" LibraryFile=\" + libfile +\n",
    "                \" samplesUp=3 nSgms=5 samplesDown=3 mode=1 OFLib=yes FilterDomain=F detectionMode=STC\" +\n",
    "                \" FilterMethod=F0 clobber=yes EventListSize=1000 EnergyMethod=OPTFILT LagsOrNot=1\" + \n",
    "                \" XMLFile=\" + xmlfile + \" filtEeV=6000.0 OFStrategy=FIXED OFLength=\" + str(pulseLength))\n",
    "        try:\n",
    "            #print(comm)\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for SIRENA reconstruction with command:\\n\", comm)\n",
    "            shutil.rmtree(tmpDir)\n",
    "            raise\n",
    "    print(\"########################\")        \n",
    "    print(\"SIRENA files created\")            \n",
    "    print(\"########################\")        \n",
    "#sys.exit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run = 0\n",
    "# 4) Correct energies from gain scale\n",
    "if run:\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        continue\n",
    "        alias = \"STC_fixedlib6OF_OPTFILT\" + str(pulseLength) + smprtStr + jitterStr + noiseStr + stochStr + bbfbStr\n",
    "        comm = (\"python convertEnergies.py --inFile=\" + evtFs[i] + \" --outFile=\" + calibFs[i] + \n",
    "                \" --coeffsFile=\" + coeffsfile + \" --alias=\" + alias)\n",
    "        try:\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for GAIN SCALE calibration with comm=\")\n",
    "            print(comm)\n",
    "            shutil.rmtree(tmpDir)\n",
    "            raise\n",
    "\n",
    "    print(\"########################\")        \n",
    "    print(\"CALIBRATED files created\")            \n",
    "    print(\"########################\")        \n",
    "#sys.exit()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Create test Files: piximpact, tessim, uncalE, calE (NOISY)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "initVars(noi='noise',sto='nostoch',bb='nobbfb',smp='samprate')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run = 0\n",
    "if run:\n",
    "    print(\"Creating PIXIMPACT test files for BBFB,SAMPRATE=\",bbfb,smprt)\n",
    "    # 1) Create Piximpact file jitter\n",
    "    # ==================================\n",
    "    for i in range(len(test_keV)):\n",
    "        comm = (\"tesconstpileup PixImpList=\" + test_impFs[i] + \" XMLFile=\" + xmlfile + \n",
    "                \" timezero=0 tstop=\" + str(texpos) + \" energy=\" + str(test_keV[i]) +\n",
    "                \" offset=\" + str(offset) + \" pulseDistance=\" + str(singleSeparation) +\n",
    "                \" TriggerSize=\" + str(triggerSizeTC) + \" clobber=yes\")\n",
    "        try:\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for piximpact list generation\")\n",
    "            os.chdir(cwd)\n",
    "            raise\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 2) Create tessim file noisy + jitter, stoch, bbfb\n",
    "# ==========================================================\n",
    "# Create individual commands for each simulation\n",
    "run = 0\n",
    "comms = []\n",
    "if run:\n",
    "    print(\"Creating TESSIM test files for BBFB,SAMPRATE=\",bbfb,smprt)\n",
    "    for i in range(0,len(test_keV)):\n",
    "        command = (\"tessim PixID=1 PixImpList=\" + test_impFs[i] + \" Streamfile=\" + test_tesFs[i] + \n",
    "                   \" tstart=0. tstop=\" + str(texpos) +  \" clobber=yes\" +\n",
    "                   \" triggerSize=\" +str(triggerSizeTS) + \" preBuffer=\" + str(preBufferSize) +\n",
    "                   \" triggertype='diff:3:20:\" + str(triggerTS3val) + \"'\" +\n",
    "                   \" sample_rate=\" + str(samprate) + \" PixType=\" + pixtype +\n",
    "                   \" doCrosstalk=n simnoise=y\" + stochastic + dobbfb)\n",
    "        comms.append(command)\n",
    "\n",
    "    # optimize for multicore: run simulation in parallel\n",
    "    nproc = cpu_count()\n",
    "    print(\"nproc=\",nproc)\n",
    "    with Pool(processes=nproc) as pool:\n",
    "        pool.starmap(tsdf, zip(comms, tesFs))\n",
    "    pool.close()\n",
    "    pool.join()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run = 1\n",
    "if run:\n",
    "    print(\"Creating SIRENA test files for BBFB,SAMPRATE=\",bbfb,smprt)\n",
    "    # 3) Run SIRENA (AD,STC)\n",
    "    # =======================\n",
    "    for i in range(0,len(test_keV)):\n",
    "        comm = (\"tesreconstruction Recordfile=\" + test_tesFs[i] + \" TesEventFile=\" + test_evtFs[i] +\n",
    "                \" Rcmethod=SIRENA\" + \" PulseLength=\" + str(pulseLength) + \" LibraryFile=\" + tlibfile +\n",
    "                \" samplesUp=3 nSgms=5 samplesDown=3 mode=1 OFLib=yes FilterDomain=F detectionMode=STC\" +\n",
    "                \" FilterMethod=F0 clobber=yes EventListSize=1000 EnergyMethod=OPTFILT LagsOrNot=1\" +\n",
    "                \" XMLFile=\" + xmlfile + \" filtEeV=6000.0 OFStrategy=FIXED OFLength=\" + str(pulseLength))\n",
    "        try:\n",
    "            print(comm)\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except RuntimeError:\n",
    "            print(\"Error running tool for SIRENA reconstruction with command:\\n\", comm)\n",
    "            raise\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run=0\n",
    "if run:\n",
    "    print(\"Creating CALIB test files for BBFB,SAMPRATE=\",bbfb,smprt)\n",
    "    # 4) Correct energies from gain scale\n",
    "    # =======================\n",
    "    for i in range(0,len(test_keV)):\n",
    "        alias = \"STC_fixedlib6OF_OPTFILT\" + str(pulseLength) + smprtStr + jitterStr + tnoiseStr + stochStr + bbfbStr\n",
    "        comm = (\"python convertEnergies.py --inFile=\" + test_evtFs[i] + \" --outFile=\" + test_calibFs[i] + \n",
    "                \" --coeffsFile=\" + coeffsfile + \" --alias=\" + alias)\n",
    "        try:\n",
    "            print(\"Running comm=\", comm)\n",
    "            args = shlex.split(comm)\n",
    "            check_call(args, stderr=STDOUT)\n",
    "        except:\n",
    "            print(\"Error running tool for GAIN SCALE calibration\")\n",
    "            shutil.rmtree(tmpDir)\n",
    "            raise\n",
    "    print(\"##################################\")\n",
    "    print(\"TEST Files created and calibrated\")\n",
    "    print(\"##################################\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  Reconstructed Energy vs Arrival Phase\n",
    "\n",
    "## a) Plot curves"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_curves_surfaces(BBFB,SMPRT):\n",
    "    STOCH = 'nostoch'\n",
    "    if BBFB == \"bbfb\":\n",
    "        STOCH = \"stoch\"\n",
    "    initVars(noi='nonoise',sto=STOCH,bb=BBFB,smp=SMPRT)\n",
    "    \"\"\"\n",
    "    Plotting curves of energy reconstruction vs arrival Phase &\n",
    "    Plotting surfaces of energy reconstruction vs arrival Phase\n",
    "    \"\"\"\n",
    "    global ph_values, phcorr_values, phase_values, phasecorr_values\n",
    "    # Find number of pulses (after cleaning of tessim files)\n",
    "    npls = list()\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        uncal = fits.open(evtFs[i], memmap=True)\n",
    "        uncalTab = uncal[1].data\n",
    "        npls.append(uncalTab.size)\n",
    "        uncal.close()\n",
    "    nfinalpulses = np.amin(npls)\n",
    "    print(\"npulses=\",nfinalpulses)\n",
    "\n",
    "    ph_values = np.zeros((len(eners_keV),nfinalpulses))\n",
    "    phcorr_values = np.zeros((len(eners_keV),nfinalpulses))\n",
    "    phase_values = np.zeros((len(eners_keV),nfinalpulses))\n",
    "    phasecorr_values = np.zeros((len(eners_keV),nfinalpulses))\n",
    "    X = np.zeros((len(eners_keV), nfinalpulses))\n",
    "    Y = np.zeros((len(eners_keV), nfinalpulses))\n",
    "    YS = np.zeros((len(eners_keV), nfinalpulses))\n",
    "    Z = np.zeros((len(eners_keV), nfinalpulses))\n",
    "\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        # Impacts\n",
    "        imp = fits.open(impFs[i], memmap=True)\n",
    "        impTab = imp[1].data\n",
    "        impTimes = impTab['TIME']\n",
    "        impIDs = impTab['PH_ID']\n",
    "        imp.close()\n",
    "\n",
    "        # Detected events\n",
    "        uncal = fits.open(evtFs[i], memmap=True)\n",
    "        uncalTab = uncal[1].data\n",
    "        uncalTimes = uncalTab['TIME']\n",
    "        uncalEners = uncalTab['SIGNAL']\n",
    "        ph_values[i,] = uncalEners[0:npulses]\n",
    "        uncal.close()\n",
    "\n",
    "        # Calibrated events\n",
    "        #cal = fits.open(calibFs[i], memmap=True)\n",
    "        #calTab = cal[1].data\n",
    "        #calTimes = calTab['TIME']\n",
    "        #calEners = calTab['SIGNAL']\n",
    "        #phcorr_values[i,] = calEners[0:npulses]\n",
    "        #cal.close()\n",
    "\n",
    "        # look for energy string in name to get simulated energy\n",
    "        srch = re.search('(?<=_)[0.]*[1-9](?=keV_STC)', calibFs[i])\n",
    "        inkeV = float(srch.group(0))\n",
    "\n",
    "        if inkeV != eners_keV[i]:\n",
    "            print(\"Error: incompatible energies in input files:\",inkeV,eners_keV[i])\n",
    "            sys.exit()\n",
    "\n",
    "        # arrival phases (see auxpy.py)\n",
    "        # If arrivalPhase1 or arrivalPhse2: \n",
    "        #             differences are calculated from non-jitter(simulated) times => if >1, subtract 1\n",
    "        #\n",
    "        # If arrivalPhase3: \n",
    "        #             differences are calculated from closest sample (0-0.5)\n",
    "        #\n",
    "        # If arrivalPhase4: \n",
    "        #             differences are calculated from previous sample (0-1)\n",
    "        #\n",
    "        #\n",
    "        #   arrPhase                non-stoch                               stoch+bbfb\n",
    "        #   ========         ============================          =================================\n",
    "        #     1/2               if >1, subtract 1                        (if >1, subtract 1) &\n",
    "        #                                                              offsets largest than minimum\n",
    "        #                                                             energy error must be moved to \n",
    "        #                                                              the left branch =>dome shape (~ -0.5-0.5)\n",
    "        #\n",
    "        #     3             Inconsistent low-high energies               ok - dome shape  (~ -0.5-0.5)\n",
    "        #                           \n",
    "        #                                         \n",
    "        #\n",
    "        #     4             offsets largest than maximum             offsets largest than minimum\n",
    "        #                   energy error must be moved to            energy error must be moved to \n",
    "        #                         the left branch                            the left branch (~ -0.5-0.5)\n",
    "        #\n",
    "        #\n",
    "\n",
    "        #\n",
    "        # For arrivalPhase3/4, offsets largest than maximum energy error must be moved to the left branch\n",
    "        #\n",
    "        # energy errors\n",
    "        #relErr = (calEners - inkeV)*100./inkeV  # [%] Relative Energy Estimation Error\n",
    "        relErr2 = (uncalEners - inkeV)*100./inkeV  # [%] Relative uncalEnergy Estimation Error\n",
    "\n",
    "        arrPhaseInit = auxpy.arrivalPhase(impF=impFs[i], evtF=evtFs[i],samprate=samprate, arrmethod=arrMeth)\n",
    "        #arrPhase = recentre_offset(arrPhaseInit, relErr, arrMeth, bbfb)      \n",
    "        arrPhase2 = recentre_offset(arrPhaseInit, relErr2, arrMeth, bbfb)    \n",
    "        phase_values[i,] = arrPhaseInit[0:npulses]\n",
    "        phasecorr_values[i,] = arrPhase2[0:npulses]\n",
    "        #print(arrPhase)\n",
    "        #print(arrPhase2)\n",
    "        #if not np.array_equal(arrPhase, arrPhase2):\n",
    "        #    raise ValueError('not equal calculation of arrival offsets:', arrPhase,arrPhase2)\n",
    "\n",
    "        \n",
    "    return\n",
    "\n",
    "    # a) Plotting CURVES\n",
    "    #======================\n",
    "    fig = plt.figure(figsize=(16,6))\n",
    "\n",
    "    # Plot RelativeErrCorrEner vs Initial Phases\n",
    "    ax = fig.add_subplot(221)\n",
    "    #ax.set_xlabel(\"Measured arrival phase\")\n",
    "    ax.set_ylabel(\"Rel. Ener estimation error (%)\\n (gain scale corrected)\")\n",
    "    for i in range(len(eners_keV)):\n",
    "        inkeV = eners_keV[i]\n",
    "        relErr = (phcorr_values[i,] - inkeV)*100./inkeV  # [%] Relative Energy Estimation Error\n",
    "        labelLeg = \"E=\" + str(inkeV) + \" keV\"\n",
    "        fc = cols[i]\n",
    "        if i % 2 == 0:\n",
    "            fc = 'none'\n",
    "        ax.plot(phase_values[i,], relErr, marker='o', markerfacecolor=fc, linestyle='none', \n",
    "                 markeredgecolor=cols[i], label=labelLeg, ms=3)\n",
    "        ax.set_xlim(-1,2)\n",
    "        ax.axvline(x=0, linestyle=\"dashed\",color=\"gray\")\n",
    "        ax.legend(numpoints=3)\n",
    "\n",
    "    # Plot RelativeErrCorrEner vs Corrected Phases\n",
    "    ax = fig.add_subplot(222)\n",
    "    #ax.set_xlabel(\"Measured & corrected arrival phase\")\n",
    "    ax.set_ylabel(\"Rel Ener estimation error (%)\\n (gain scale corrected)\")\n",
    "    for i in range(len(eners_keV)):\n",
    "        inkeV = eners_keV[i]\n",
    "        relErr = (phcorr_values[i,] - inkeV)*100./inkeV  # [%] Relative Energy Estimation Error\n",
    "        labelLeg = \"E=\" + str(inkeV) + \" keV\"\n",
    "        fc = cols[i]\n",
    "        if i % 2 == 0:\n",
    "            fc = 'none'\n",
    "        ax.plot(phasecorr_values[i,], relErr, marker='o', markerfacecolor=fc, linestyle='none', \n",
    "                 markeredgecolor=cols[i], label=labelLeg, ms=3)\n",
    "        ax.set_xlim(-1,2)\n",
    "        ax.axvline(x=0, linestyle=\"dashed\",color=\"gray\")\n",
    "        ax.legend(numpoints=3)\n",
    "\n",
    "    # Plot RelativeErrUncorrEner vs Initial Phases\n",
    "    ax = fig.add_subplot(223)\n",
    "    ax.set_xlabel(\"Measured arrival phase\")\n",
    "    ax.set_ylabel(\"Relative Energy estimation error (%)\\n (uncalibrated)\")\n",
    "    for i in range(len(eners_keV)):\n",
    "        inkeV = eners_keV[i]\n",
    "        relErr = (ph_values[i,] - inkeV)*100./inkeV  # [%] Relative Energy Estimation Error\n",
    "        labelLeg = \"E=\" + str(inkeV) + \" keV\"\n",
    "        fc = cols[i]\n",
    "        if i % 2 == 0:\n",
    "            fc = 'none'\n",
    "        ax.plot(phase_values[i,], relErr, marker='o', markerfacecolor=fc, linestyle='none', \n",
    "                 markeredgecolor=cols[i], label=labelLeg, ms=3)\n",
    "        ax.set_xlim(-1,2)\n",
    "        ax.axvline(x=0, linestyle=\"dashed\",color=\"gray\")\n",
    "        ax.legend(numpoints=3)\n",
    "\n",
    "    # Plot RelativeErrCorrEner vs Corrected Phases\n",
    "    ax = fig.add_subplot(224)\n",
    "    ax.set_xlabel(\"Measured & corrected arrival phase\")\n",
    "    ax.set_ylabel(\"Relative Energy estimation error (%)\\n (uncalibrated)\")\n",
    "    for i in range(len(eners_keV)):\n",
    "        inkeV = eners_keV[i]\n",
    "        relErr = (ph_values[i,] - inkeV)*100./inkeV  # [%] Relative Energy Estimation Error\n",
    "        labelLeg = \"E=\" + str(inkeV) + \" keV\"\n",
    "        fc = cols[i]\n",
    "        if i % 2 == 0:\n",
    "            fc = 'none'\n",
    "        ax.plot(phasecorr_values[i,], relErr, marker='o', markerfacecolor=fc, linestyle='none', \n",
    "                 markeredgecolor=cols[i], label=labelLeg, ms=3)\n",
    "        ax.set_xlim(-1,2)\n",
    "        ax.axvline(x=0, linestyle=\"dashed\",color=\"gray\")\n",
    "        ax.legend(numpoints=3)\n",
    "\n",
    "    # b)Plotting SURFACES\n",
    "    # ====================\n",
    "    # PLOT      EcalibError  vs. offset  vs. Einput\n",
    "    fig = plt.figure(figsize=(16,6))\n",
    "    fig.suptitle('Error in (cal)Energy estimation', fontsize=14, fontweight='bold')\n",
    "\n",
    "    ax = fig.add_subplot(131, projection='3d')\n",
    "    ax.set_xlabel('arrival phases')\n",
    "    ax.set_ylabel('Rel. E estim (cal) %')\n",
    "    ax.set_zlabel('Input energy (keV)')\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        X[i,] = phasecorr_values[i,]\n",
    "        Y[i,] = (phcorr_values[i,]-eners_keV[i])*100./eners_keV[i]\n",
    "        Z[i,] = np.repeat(eners_keV[i], npulses)\n",
    "        #XS[i,] = np.sort(X[i,],0)\n",
    "        YS[i,] = [x for _,x in sorted(zip(X[i,],Y[i,]))]\n",
    "        ax.scatter(xs=X[i,], ys=Y[i,], zs=eners_keV[i], zdir='z', s=20, c=cols[i], depthshade=True)\n",
    "    XS = np.sort(X,1)\n",
    "\n",
    "    ax2 = fig.add_subplot(132, projection='3d')\n",
    "    ax2.plot_wireframe(X=XS, Y=YS, Z=Z)\n",
    "    ax2.set_xlabel('Corr arrival phases')\n",
    "    ax2.set_ylabel('Rel. E estim (cal) %')\n",
    "    ax2.set_zlabel('Input energy (keV)')\n",
    "\n",
    "    ax3 = fig.add_subplot(133, projection='3d')\n",
    "    surf = ax3.plot_surface(X=XS, Y=YS, Z=Z, cmap=cm.coolwarm, antialiased=True)\n",
    "    ax3.set_xlabel('Corr arrival phases')\n",
    "    ax3.set_ylabel('Rel. E estim (cal) %')\n",
    "    ax3.set_zlabel('Input energy (keV)')\n",
    "    fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "    # PLOT      Euncalib  vs. offset  vs. Einput\n",
    "    fig = plt.figure(figsize=(16,6))\n",
    "    fig.suptitle('Uncalibrated Energy estimation', fontsize=14, fontweight='bold')\n",
    "\n",
    "    ax = fig.add_subplot(131, projection='3d')\n",
    "    ax.set_xlabel('Corr arrival phases')\n",
    "    ax.set_ylabel('Uncal E (keV)')\n",
    "    ax.set_zlabel('Input energy (keV)')\n",
    "    for i in range(0,len(eners_keV)):\n",
    "        Y[i,] = ph_values[i,]\n",
    "        YS[i,] = [x for _,x in sorted(zip(X[i,],Y[i,]))]\n",
    "        ax.scatter(xs=X[i,], ys=Y[i,], zs=eners_keV[i], zdir='z', s=20, c=cols[i], depthshade=True)\n",
    "    XS = np.sort(X,1)\n",
    "\n",
    "    ax2 = fig.add_subplot(132, projection='3d')\n",
    "    ax2.plot_wireframe(X=XS, Y=YS, Z=Z)\n",
    "    ax2.set_xlabel('Corr arrival phases')\n",
    "    ax2.set_ylabel('Uncal E (keV)')\n",
    "    ax2.set_zlabel('Input energy (keV)')\n",
    "\n",
    "    ax3 = fig.add_subplot(133, projection='3d')\n",
    "    surf = ax3.plot_surface(X=XS, Y=YS, Z=Z, cmap=cm.coolwarm, antialiased=True)\n",
    "    ax3.set_xlabel('Corr arrival phases')\n",
    "    ax3.set_ylabel('Uncal E (keV)')\n",
    "    ax3.set_zlabel('Input energy (keV)')\n",
    "    fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "    # PLOT      Ecalib  vs. offset  vs. Einput\n",
    "    # ===============================================\n",
    "    #fig = plt.figure(figsize=(16,6))\n",
    "    #fig.suptitle('Calibrated Energy', fontsize=14, fontweight='bold')\n",
    "    #\n",
    "    #ax = fig.add_subplot(131, projection='3d')\n",
    "    #ax.set_xlabel('Corr arrival phases')\n",
    "    #ax.set_ylabel('Calib E (keV)')\n",
    "    #ax.set_zlabel('Input energy (keV)')\n",
    "    #for i in range(0,len(eners_keV)):\n",
    "    #    Y[i,] = phcorr_values[i,]\n",
    "    #    YS[i,] = [x for _,x in sorted(zip(X[i,],Y[i,]))]\n",
    "    #    ax.scatter(xs=X[i,], ys=Y[i,], zs=eners_keV[i], zdir='z', s=20, c=cols[i], depthshade=True)\n",
    "    #XS = np.sort(X,1)\n",
    "    #\n",
    "    #ax2 = fig.add_subplot(132, projection='3d')\n",
    "    #ax2.plot_wireframe(X=XS, Y=YS, Z=Z)\n",
    "    #ax2.set_xlabel('Corr arrival phases')\n",
    "    #ax2.set_ylabel('Calib E (keV)')\n",
    "    #ax2.set_zlabel('Input energy (keV)')\n",
    "    #\n",
    "    #ax3 = fig.add_subplot(133, projection='3d')\n",
    "    #surf = ax3.plot_surface(X=XS, Y=YS, Z=Z, cmap=cm.coolwarm, antialiased=True)\n",
    "    #ax3.set_xlabel('Corr arrival phases')\n",
    "    #ax3.set_ylabel('Calib E (keV)')\n",
    "    #ax3.set_zlabel('Input energy (keV)')\n",
    "    #fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Test files energy corrections\n",
    "\n",
    "Compare resconstructed energies @ 1keV and 7 keV before and after corrections.\n",
    "For this, we use *tpulses* reconstructed with a *jitter_noisy* library using the coefficients calculated below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "def plot_Ecorr():\n",
    "    \"\"\"\n",
    "    Plot corrected energies: run ALWAYS AFTER plot_curves_surfaces\n",
    "    \"\"\"\n",
    "    initVars(noi='noise',sto='nostoch',bb='nobbfb',smp='samprate')\n",
    "\n",
    "    print(\"Correcting energies for \", tpulses, \"pulses and samprate=\",smprt)\n",
    "    \n",
    "    #Fitting of a 2D polynomial to Unrecons vs Offsets\n",
    "    #Based on PP functions. Functions input:\n",
    "    #    * Uncorr energies (ph_values): energies are reconstructed with a 50p library (jitter_nonoise)\n",
    "    #    * UnCorrected Arrival Phases (phase_values)\n",
    "    #    * Calibration Energies (energy_list)\n",
    "    print(\"Test of fitting with files:\")\n",
    "    print(test_evtFs[0],test_evtFs[1])\n",
    "    print(\"Einput=\", eners_keV[0])\n",
    "    print(\"phasecorr_values=\",phasecorr_values[0,1])\n",
    "    print(\"phcorr_values=\",phcorr_values[0,1])\n",
    "    print(\"ph_values=\",ph_values[0,1])\n",
    "    coeffs=fit_2D_gain_scale(ph_values, phasecorr_values, eners_keV, deg=6, show=True)\n",
    "    #print(coeffs)\n",
    "    corrE = 0.\n",
    "    corrE = np.polynomial.polynomial.polyval2d(ph_values[0,1],phasecorr_values[0,1],coeffs)\n",
    "    print(\"corrE=\", corrE)\n",
    "    \n",
    "    ph_test = np.zeros((len(test_keV),tpulses-1))\n",
    "    phase_test = np.zeros((len(test_keV),tpulses-1))\n",
    "    phasecorr_test = np.zeros((len(test_keV),tpulses-1))\n",
    "    corrE = np.zeros((len(test_keV),tpulses-1))\n",
    "\n",
    "    fig = plt.figure(figsize=(16,6))\n",
    "\n",
    "    for i in range(0,len(test_keV)):\n",
    "        # Detected uncal events\n",
    "        uncal = fits.open(test_evtFs[i], memmap=True)\n",
    "        uncalTab = uncal[1].data\n",
    "        uncalEners = uncalTab['SIGNAL']\n",
    "        uncal.close()\n",
    "        # Detected cal events\n",
    "        cal = fits.open(test_calibFs[i], memmap=True)\n",
    "        calTab = cal[1].data\n",
    "        calEners = calTab['SIGNAL']\n",
    "        cal.close()\n",
    "\n",
    "        # Arrival Phases & Corrected energies\n",
    "        arrPhase = auxpy.arrivalPhase(impF=test_impFs[i], evtF=test_evtFs[i],samprate=samprate, arrmethod=arrMeth)\n",
    "        relErr = (uncalEners - test_keV[i])*100./test_keV[i]\n",
    "        arrPhaseCorr = recentre_offset(arrPhase, relErr, arrMeth, bbfb) \n",
    "        arrPhaseMid = (np.max(arrPhaseCorr)-abs(np.min(arrPhaseCorr)))/2.\n",
    "        corrE = np.polynomial.polynomial.polyval2d(uncalEners, arrPhaseCorr,coeffs)\n",
    "        #print(\"Einput=\",test_keV[i])\n",
    "        #print(\"minArrPhase:\",np.amin(arrPhase))\n",
    "        #print(\"maxArrPhase:\",np.amax(arrPhase))\n",
    "        fwhmUnCal = 'FWHM={0:0.2f}eV'.format(2.35*np.std(uncalEners)*1000) # eV\n",
    "        fwhmCal = 'FWHM={0:0.2f}eV'.format(2.35*np.std(calEners)*1000) # eV\n",
    "        fwhmCorr = 'FWHM={0:0.2f}eV'.format(2.35*np.std(corrE)*1000) # eV\n",
    "        #print(\"sd(Cal):\", stdCal)\n",
    "        #print(\"sd(Corr):\", stdCorr)\n",
    "\n",
    "        # Plot Corr UnCalE vs ArrPhse\n",
    "        figstr = \"23\"+str(3*i+1)\n",
    "        ax = fig.add_subplot(figstr)\n",
    "        ax.set_xlabel(\"Measured & Corr arrival phase\")\n",
    "        ax.set_ylabel(\"UnCalib Energy (keV)\")\n",
    "        ax.plot(arrPhaseCorr, uncalEners, marker='o', linestyle='none', ms=3)\n",
    "        #ax.text(arrPhaseMid,np.max(uncalEners), r'$FWHM=fwhmUnCal$')\n",
    "        ax.annotate(fwhmUnCal, xy=(arrPhaseMid,0.998*np.max(uncalEners)))\n",
    "\n",
    "        # Plot Corr CalE vs ArrPhse\n",
    "        figstr = \"23\"+str(3*i+2)\n",
    "        ax = fig.add_subplot(figstr)\n",
    "        ax.set_xlabel(\"Measured & Corr arrival phase\")\n",
    "        ax.set_ylabel(\"Calibrated Energy (keV)\")\n",
    "        ax.plot(arrPhaseCorr, calEners, marker='o', linestyle='none', ms=3)\n",
    "        ax.annotate(fwhmCal, xy=(arrPhaseMid,0.998*np.max(calEners)))\n",
    "\n",
    "        # Plot Corr CorrE vs ArrPhse\n",
    "        figstr = \"23\"+str(3*i+3)\n",
    "        ax = fig.add_subplot(figstr)\n",
    "        ax.set_xlabel(\"Measured & Corr arrival phase\")\n",
    "        ax.set_ylabel(\"Corrected Energy (keV)\")\n",
    "        ax.plot(arrPhaseCorr, corrE, marker='o', linestyle='none', ms=3)\n",
    "        ax.annotate(fwhmCorr, xy=(arrPhaseMid,0.998*np.max(corrE)))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "interact(plot_curves_surfaces, BBFB=['nobbfb','bbfb'], SMPRT=['samprate','samprate2'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_Ecorr()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comments\n",
    "* Si los coefficientes se calculan con los offsets iniciales, la corrección es peor que si se calculan con los offset \"arreglados\"\n",
    "* no hay diferencia entre calcular los coeficientes con las energías calibradas o no calibradas\n",
    "* Probar a calcular coeficientes con más de 50 puntos => con 100 o 1000 puntos sale parecido..."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
